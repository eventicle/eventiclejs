### YamlMime:TSType
name: Command
uid: '@eventicle/eventiclejs!Command:interface'
package: '@eventicle/eventiclejs!'
fullName: Command
summary: >-
  Defines a command handler in Eventicle's CQRS architecture.


  Commands encapsulate business operations that change system state and emit domain events. They provide the "C" in
  CQRS, handling write operations while maintaining strong consistency and business rule enforcement.

   I - Input data type for the command  O - Output/response type from the command

  Key Features: - \*\*Business Logic\*\*: Encapsulates domain operations and invariants - \*\*Event Generation\*\*:
  Produces events representing state changes - \*\*Type Safety\*\*: Strongly-typed input/output contracts -
  \*\*Transactional\*\*: Atomic execution with event emission - \*\*Scalable\*\*: Can be distributed across multiple
  instances
remarks: ''
example:
  - |-
    User management command

    ```typescript
    const createUserCommand: Command<{email: string, name: string}, {userId: string}> = {
      type: 'CreateUser',
      streamToEmit: 'users',
      execute: async (data) => {
        // Validate business rules
        await validateUniqueEmail(data.email);

        // Create aggregate and apply business logic
        const user = User.create(data.email, data.name);

        // Persist and get generated events
        const events = await aggregates.persist(user);

        return {
          response: { userId: user.id },
          events
        };
      }
    };
    ```
  - |-
    Order processing with error handling

    ```typescript
    const processOrderCommand: Command<OrderData, {orderId: string}> = {
      type: 'ProcessOrder',
      streamToEmit: 'orders',
      execute: async (data) => {
        try {
          const order = await aggregates.load(Order, data.orderId);
          order.process(data.items);

          return {
            response: { orderId: order.id },
            events: await aggregates.persist(order)
          };
        } catch (error) {
          // Emit failure event and propagate error
          return {
            events: [{
              type: 'OrderProcessingFailed',
              domainId: data.orderId,
              data: { error: error.message }
            }],
            webError: new Error('Order processing failed')
          };
        }
      }
    };
    ```
isPreview: false
isDeprecated: false
type: interface
properties:
  - name: execute
    uid: '@eventicle/eventiclejs!Command#execute:member'
    package: '@eventicle/eventiclejs!'
    fullName: execute
    summary: |-
      The command handler function. The data will be received from the CommandIntent

      This may be called concurrently.

      This should attempt to modify the system and then emit events to represent the change.
    remarks: ''
    example:
      - |-
        the most command pattern is to use an AggregateRoot to generate the events

        ```
         const myCommand = {
           type: "approve-user",
           streamToEmit: "user",
           execute: async (data) => {
              const user = await aggregates.load(UserAggregate, data.userId);
              user.approve();
              return {
                // aggregates returns all the events that were generated after the
                // aggregate was loaded, after it has persisted.
                events: await aggregates.persist(user);
              }
           }
         }
        ```
        this can be called like so

        \`\`\` async function example() { // other setup await registerCommand(myCommand);

        await dispatchCommand(<!-- -->{ type: "something", data: { userId: "theuser" } }<!-- -->); }

        example(); \`\`\`
    isPreview: false
    isDeprecated: false
    syntax:
      content: 'execute: (data: I) => Promise<CommandReturn<O>>;'
      return:
        type: '(data: I) =&gt; Promise&lt;<xref uid="@eventicle/eventiclejs!CommandReturn:interface" />&lt;O&gt;&gt;'
  - name: streamToEmit
    uid: '@eventicle/eventiclejs!Command#streamToEmit:member'
    package: '@eventicle/eventiclejs!'
    fullName: streamToEmit
    summary: >-
      Target event stream for publishing generated events.


      All events returned by the command execution will be published to this stream, making them available to event
      views, sagas, and other subscribers.
    remarks: ''
    example: []
    isPreview: false
    isDeprecated: false
    syntax:
      content: 'streamToEmit: string;'
      return:
        type: string
  - name: type
    uid: '@eventicle/eventiclejs!Command#type:member'
    package: '@eventicle/eventiclejs!'
    fullName: type
    summary: >-
      Unique command type identifier used for registration and dispatch.


      Should be descriptive and follow consistent naming conventions (e.g., 'CreateUser', 'ProcessPayment',
      'CancelOrder').
    remarks: ''
    example: []
    isPreview: false
    isDeprecated: false
    syntax:
      content: 'type: string;'
      return:
        type: string
