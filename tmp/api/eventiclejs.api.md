## API Report File for "@eventicle/eventiclejs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { ConsumerConfig } from 'kafkajs';
import { ConsumerRunConfig } from 'kafkajs';
import { DataQuery } from '@eventicle/eventicle-utilities/dist/datastore';
import { DataSorting } from '@eventicle/eventicle-utilities/dist/datastore';
import { DataStore } from '@eventicle/eventicle-utilities/dist/datastore';
import { dataStore } from '@eventicle/eventicle-utilities/dist/datastore';
import { DefaultContext } from 'xstate';
import { EventEmitter } from 'events';
import { EventObject } from 'xstate';
import { Interpreter } from 'xstate';
import { KafkaConfig } from 'kafkajs';
import { lockManager } from '@eventicle/eventicle-utilities';
import { LockManager as LockManager_2 } from '@eventicle/eventicle-utilities';
import { LogApi } from '@eventicle/eventicle-utilities';
import * as nodeCron from 'node-cron';
import { PagedRecords } from '@eventicle/eventicle-utilities/dist/datastore';
import { Query } from '@eventicle/eventicle-utilities/dist/datastore';
import { Record as Record_2 } from '@eventicle/eventicle-utilities/dist/datastore';
import { ScheduleJobRunner } from '@eventicle/eventicle-utilities/dist/schedule-job-runner';
import { setDataStore } from '@eventicle/eventicle-utilities/dist/datastore';
import { setLockManager } from '@eventicle/eventicle-utilities';
import { setLogApi } from '@eventicle/eventicle-utilities';
import { TransactionData } from '@eventicle/eventicle-utilities/dist/datastore';
import { TransactionListener } from '@eventicle/eventicle-utilities/dist/datastore';
import { TransactionOptions } from '@eventicle/eventicle-utilities/dist/datastore';
import { TypegenDisabled } from 'xstate';

// Warning: (ae-forgotten-export) The symbol "AggregateObservationAdapter" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const aggregateObservationAdapter: () => AggregateObservationAdapter;

// @public
export function aggregateObserver<AR extends AggregateRoot>(aggregateType: {
    new (...params: any[]): AR;
}, id: string, timeout: number, exec: (ar: AR, event?: EventicleEvent) => boolean): Promise<AR>;

// @public (undocumented)
export abstract class AggregateRoot {
    constructor(type: string | AggregateConfig);
    // Warning: (ae-forgotten-export) The symbol "AggregateConfig" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly config: AggregateConfig;
    // (undocumented)
    currentCheckpoint(): object;
    // (undocumented)
    handleEvent(event: EventicleEvent): void;
    // (undocumented)
    history: EventicleEvent[];
    // (undocumented)
    id: string;
    // (undocumented)
    newEvents: EventicleEvent[];
    // (undocumented)
    raiseEvent(event: EventicleEvent): EventicleEvent;
    // (undocumented)
    reducers: any;
    // (undocumented)
    replaying: boolean;
    // (undocumented)
    get type(): string;
}

// Warning: (ae-forgotten-export) The symbol "AggregateRepository" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const aggregates: AggregateRepository;

// @public (undocumented)
export function allSagaInstances(workspaceId?: string): Promise<SagaInstance<any, any>[]>;

// @public (undocumented)
export function allSagas(): Promise<Saga<any, any>[]>;

declare namespace apm {
    export {
        apmJoinEvent
    }
}
export { apm }

// @public
function apmJoinEvent(event: EventicleEvent, name: string, type: string, subtype: string): void;

// @public
export interface Command<I, O> {
    execute: (data: I) => Promise<CommandReturn<O>>;
    streamToEmit: string;
    type: string;
}

// @public
export interface CommandIntent<T> {
    data: T;
    type: string;
}

// @public
export interface CommandReturn<T> {
    events: EventicleEvent[];
    response?: T;
    webError?: Error;
}

// @public (undocumented)
export function connectBroker(config: KafkaConfig): Promise<void>;

// @public
export function consumeFullEventLog(stream: string): Promise<EventicleEvent[]>;

// @public
export function createAggregateObservationAdapter<AR extends AggregateRoot>(aggregates: {
    new (): AR;
}[]): AggregateObservationAdapter;

export { DataQuery }

export { DataSorting }

export { DataStore }

export { dataStore }

// @public
export function dispatchCommand<T>(commandIntent: CommandIntent<T>): Promise<CommandReturn<T>>;

// @public
export function dispatchDirectCommand<T>(command: () => Promise<CommandReturn<T>>, streamToEmit: string): Promise<T>;

// @public (undocumented)
export interface EncodedEvent {
    // (undocumented)
    buffer: Buffer;
    // (undocumented)
    headers: {
        [key: string]: any;
    };
    // (undocumented)
    key: string;
    // (undocumented)
    timestamp: number;
}

// @public
export interface EventAdapter {
    // (undocumented)
    consumerGroup: string;
    // (undocumented)
    errorHandler?: (adapter: EventAdapter, event: EventicleEvent, error: Error) => Promise<void>;
    // (undocumented)
    handleEvent: (event: EventicleEvent) => Promise<void>;
    // (undocumented)
    name: string;
    // (undocumented)
    streamsToSubscribe: string[];
}

// @public (undocumented)
export interface EventClient {
    coldHotStream: (config: {
        rawEvents: true;
        stream: string | string[];
        groupId?: string;
        handler: (event: EncodedEvent) => Promise<void>;
        onError: (error: any) => void;
    } | {
        rawEvents: false;
        stream: string | string[];
        groupId?: string;
        handler: (event: EventicleEvent) => Promise<void>;
        onError: (error: any) => void;
    } | {
        stream: string | string[];
        groupId?: string;
        handler: (event: EventicleEvent) => Promise<void>;
        onError: (error: any) => void;
    }) => Promise<EventSubscriptionControl>;
    // Warning: (ae-forgotten-export) The symbol "EventSubscriptionControl" needs to be exported by the entry point index.d.ts
    coldStream: (stream: string, handler: (event: EventicleEvent) => Promise<void>, onError: (error: any) => void, onDone: () => void) => Promise<EventSubscriptionControl>;
    // (undocumented)
    emit: (event: EventicleEvent[] | EncodedEvent[], stream: string) => Promise<void>;
    hotRawStream: (stream: string | string[], consumerName: string, handler: (event: EncodedEvent) => Promise<void>, onError: (error: any) => void) => Promise<EventSubscriptionControl>;
    hotStream: (stream: string | string[], consumerName: string, handler: (event: EventicleEvent) => Promise<void>, onError: (error: any) => void) => Promise<EventSubscriptionControl>;
    // (undocumented)
    isConnected: () => boolean;
    // (undocumented)
    shutdown: () => Promise<void>;
}

// @public (undocumented)
export function eventClient(): EventClient;

// @public
export interface EventClientCodec {
    // (undocumented)
    decode: (encoded: EncodedEvent) => Promise<EventicleEvent>;
    encode: (event: EventicleEvent) => Promise<EncodedEvent>;
}

// @public (undocumented)
export function eventClientCodec(): EventClientCodec;

// @public
export function eventClientOnDatastore(): EventClient;

// Warning: (ae-forgotten-export) The symbol "ConsumerConfigFactory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function eventClientOnKafka(config: KafkaConfig, consumerConfig?: ConsumerConfigFactory): Promise<EventClient>;

// @public (undocumented)
export interface EventicleEvent {
    // (undocumented)
    causedById?: string;
    // (undocumented)
    causedByType?: string;
    // (undocumented)
    createdAt?: number;
    // (undocumented)
    data: any;
    // (undocumented)
    domainId?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    source?: string;
    // (undocumented)
    stream?: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export function eventSourceName(): string;

// @public (undocumented)
export interface EventView {
    // (undocumented)
    consumerGroup: string;
    // (undocumented)
    handleEvent: (event: EventicleEvent) => Promise<void>;
    // (undocumented)
    streamsToSubscribe: string[];
}

// @public
export class implements DataStore {
    // (undocumented)
    createEntity(workspaceId: string, type: string, item: any): Promise<any>;
    // (undocumented)
    deleteEntity(workspaceId: string, type: string, id: string): Promise<void>;
    // (undocumented)
    deleteMany(workspaceId: string, type: string, query: Query): Promise<void>;
    // (undocumented)
    events: EventEmitter;
    // (undocumented)
    findEntity(workspaceId: string, type: any, query: Query, sorting?: DataSorting): Promise<Record_2[]>;
    // (undocumented)
    findEntityPaginated(workspaceId: string, type: string, query: Query, sorting: DataSorting, page: number, pageSize: number): Promise<PagedRecords>;
    // (undocumented)
    getEntity(workspaceId: string, type: any, id: string): Promise<Record_2>;
    // (undocumented)
    getTransactionData(): TransactionData;
    // (undocumented)
    hasTransactionData(): boolean;
    // (undocumented)
    on(event: "transaction.start" | "transaction.commit", listener: (name: string, data: TransactionData) => void): this;
    // (undocumented)
    purge(): Promise<void>;
    // (undocumented)
    saveEntity(workspaceId: string, type: string, item: Record_2): Promise<Record_2>;
    // (undocumented)
    transaction<T>(exec: () => Promise<T>): Promise<T>;
}

// @public
export class LocalScheduleJobRunner implements ScheduleJobRunner {
    constructor();
    // (undocumented)
    addScheduledTask(component: string, name: string, id: string, config: {
        isCron: true;
        crontab: string;
    } | {
        isCron: false;
        timeout: number;
    }, data: any): Promise<void>;
    // (undocumented)
    addScheduleTaskListener(component: string, exec: (name: string, id: string, data: any) => Promise<void>): Promise<void>;
    // (undocumented)
    clearAllTimers(): void;
    // (undocumented)
    crons: Map<string, nodeCron.ScheduledTask>;
    // (undocumented)
    events: EventEmitter;
    // (undocumented)
    hasSchedule(component: string, name: string, id: string): Promise<boolean>;
    // (undocumented)
    removeSchedule(component: string, name: string, id: string): Promise<void>;
    // (undocumented)
    startup(): Promise<void>;
    // (undocumented)
    timers: Map<string, NodeJS.Timeout>;
}

export { lockManager }

export { LockManager_2 as LockManager }

export { LogApi }

// @public (undocumented)
export function metrics(): {
    "view-latency": any;
    "adapter-latency": any;
    "saga-latency": any;
};

export { PagedRecords }

// @public (undocumented)
export interface RawEventView {
    // (undocumented)
    consumerGroup: string;
    // (undocumented)
    handleEvent: (event: EncodedEvent) => Promise<void>;
    // (undocumented)
    streamsToSubscribe: string[];
}

export { Record_2 as Record }

// @public
export function registerAdapter(adapter: EventAdapter): Promise<EventSubscriptionControl>;

// @public (undocumented)
export function registerCommand<I, O>(command: Command<I, O>): void;

// @public
export function registerRawView(view: RawEventView): Promise<EventSubscriptionControl>;

// @public (undocumented)
export function registerSaga<TimeoutNames, Y>(saga: Saga<TimeoutNames, Y>): Promise<EventSubscriptionControl>;

// @public (undocumented)
export function registerView(view: EventView): Promise<EventSubscriptionControl>;

// @public (undocumented)
export function removeAllSagas(): Promise<void>;

// @public
export function removeXstateEvents(events: EventicleEvent[]): EventicleEvent[];

// @public
export class Saga<TimeoutNames, InstanceData> {
    constructor(name: string);
    // (undocumented)
    errorHandler: (saga: any, event: EventicleEvent, error: Error) => Promise<void>;
    // (undocumented)
    eventHandler: Map<string, {
        config: HandlerConfig<any, InstanceData, TimeoutNames>;
        handle: (saga: SagaInstance<TimeoutNames, InstanceData>, event: EventicleEvent) => Promise<void>;
    }>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    on<T extends EventicleEvent>(eventName: string, config: HandlerConfig<T, InstanceData, TimeoutNames>, handler: (saga: SagaInstance<TimeoutNames, InstanceData>, event: T) => Promise<void>): Saga<TimeoutNames, InstanceData>;
    // (undocumented)
    onError(handler: (saga: any, event: EventicleEvent, error: Error) => Promise<void>): Saga<TimeoutNames, InstanceData>;
    onTimer(name: TimeoutNames, handle: (saga: SagaInstance<TimeoutNames, InstanceData>) => Promise<void>): Saga<TimeoutNames, InstanceData>;
    // (undocumented)
    startOn<T extends EventicleEvent>(eventName: string, config: StartHandlerConfig<T, InstanceData, TimeoutNames>, handler: (saga: SagaInstance<TimeoutNames, InstanceData>, event: T) => Promise<void>): Saga<TimeoutNames, InstanceData>;
    // (undocumented)
    starts: Map<string, {
        config: StartHandlerConfig<any, InstanceData, TimeoutNames>;
        handle: (saga: SagaInstance<TimeoutNames, InstanceData>, event: EventicleEvent) => Promise<void>;
    }>;
    // (undocumented)
    streams: string[];
    // (undocumented)
    streamSubs: EventSubscriptionControl[];
    // (undocumented)
    subscribeStreams(streams: string[]): Saga<TimeoutNames, InstanceData>;
    // (undocumented)
    timerHandler: Map<TimeoutNames, {
        handle: (saga: SagaInstance<TimeoutNames, InstanceData>) => Promise<void>;
    }>;
}

// @public (undocumented)
export function saga<TimeoutNames, SagaInstanceData>(name: string): Saga<TimeoutNames, SagaInstanceData>;

// @public
export class SagaInstance<TimeoutNames, T> {
    constructor(internalData: any, record?: Record_2);
    // (undocumented)
    endSaga(preserveInstanceData?: boolean): void;
    get(name: keyof T): any;
    // (undocumented)
    readonly internalData: any;
    // (undocumented)
    lastEvent(): EventicleEvent;
    // (undocumented)
    readonly record?: Record_2;
    // (undocumented)
    removeTimer(name: TimeoutNames): void;
    set(name: keyof T, value: any): void;
    readonly timersToAdd: {
        name: TimeoutNames;
        config: {
            isCron: true;
            crontab: string;
        } | {
            isCron: false;
            timeout: number;
        };
    }[];
    readonly timersToRemove: TimeoutNames[];
    upsertTimer(name: TimeoutNames, config: {
        isCron: true;
        crontab: string;
    } | {
        isCron: false;
        timeout: number;
    }): void;
}

// @public (undocumented)
export function scheduler(): ScheduleJobRunner;

export { setDataStore }

// @public (undocumented)
export function setEventClient(cl: EventClient): void;

// @public (undocumented)
export function setEventClientCodec(cl: EventClientCodec): void;

// @public (undocumented)
export function setEventSourceName(name: string): void;

export { setLockManager }

export { setLogApi }

// @public (undocumented)
export function setScheduler(scheduler: ScheduleJobRunner): void;

export { TransactionData }

export { TransactionListener }

export { TransactionOptions }

// @public
export class XStateAggregate<MACHINE> extends AggregateRoot {
    constructor(type: string, machineFactory: (_this: any) => any);
    // (undocumented)
    handleEvent(event: EventicleEvent): void;
    // (undocumented)
    protected initStateMachineService(initialState?: any): void;
    // (undocumented)
    readonly machineFactory: (_this: any) => any;
    // (undocumented)
    raiseEvent(event: EventicleEvent): EventicleEvent;
    service: Interpreter<DefaultContext, any, EventObject, {
        value: any;
        context: DefaultContext;
    }, TypegenDisabled>;
    // (undocumented)
    shutdown(): void;
    protected xsend(msg: any): void;
}

// Warnings were encountered during analysis:
//
// src/events/saga/index.ts:180:25 - (ae-forgotten-export) The symbol "StartHandlerConfig" needs to be exported by the entry point index.d.ts
// src/events/saga/index.ts:181:31 - (ae-forgotten-export) The symbol "HandlerConfig" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
